# 跨文件引用验证功能设计与实现

## 概述

基于您的设计思路，我们实现了一个基于SchemaRegistry的"辅助检测接口"机制，解决了OData XML文件跨文件引用验证的问题。

## 核心设计理念

### 问题分析
在单个OData XML文件检测时，需要进行以下判断：
1. 引入的文件是否存在
2. 引入的文件是否有对应namespace的schema
3. 引用其他文件中的EntityType、ComplexType等所有可以被其他文件引用的Element，在被引用文件中是否存在

### 解决方案
通过"辅助检测接口"（SchemaRegistry）实现解耦，该接口具备以下能力：
1. **数据收集**：在验证前解析所有XML文件，将Schema信息注册到Registry中
2. **引用检查**：在单文件验证时，通过Registry检查跨文件引用的正确性
3. **数据导出**：验证通过的数据可以导出，作为后续验证的基础数据

## 架构实现

### 核心组件

#### 1. SchemaRegistry（辅助检测接口）
```java
public class SchemaRegistry {
    // 新增方法支持跨文件引用验证
    public boolean hasNamespace(String namespace);
    public boolean hasSchemaForFile(String filePath);
    public boolean isTypeExists(String typeName);
    public Set<SchemaDefinition> getSchemasForFile(String filePath);
    public SchemaDefinition getSchemaByNamespace(String namespace);
}
```

#### 2. ValidationContext扩展
```java
public class ValidationContext {
    // 新增SchemaRegistry支持
    private SchemaRegistry schemaRegistry;
    
    public SchemaRegistry getSchemaRegistry();
    public void setSchemaRegistry(SchemaRegistry schemaRegistry);
}
```

#### 3. CrossFileReferenceValidationRule
新的验证规则，专门处理跨文件引用验证：
- 验证edmx:Reference声明的URI对应的Schema是否在Registry中存在
- 验证edmx:Include声明的Namespace是否在Registry中存在
- 验证Schema中的类型引用是否在Registry中存在

#### 4. EnhancedRegistryAwareXmlValidator
增强的单文件验证器，支持SchemaRegistry注入和跨文件引用验证

## 使用流程

### 基础验证流程
```java
// 1. 创建SchemaRegistry并注册所有Schema
SchemaRegistry registry = new SchemaRegistry();
for (File xmlFile : xmlFiles) {
    List<SchemaRegistry.SchemaDefinition> schemas = schemaExtractor.extractSchemas(xmlFile);
    for (SchemaRegistry.SchemaDefinition schema : schemas) {
        registry.registerSchema(schema);
    }
}

// 2. 使用增强验证器进行单文件验证
EnhancedRegistryAwareXmlValidator validator = new EnhancedRegistryAwareXmlValidator();
XmlComplianceResult result = validator.validateWithRegistry(xmlFile, registry);
```

### 目录验证流程
```java
DirectoryValidationManager manager = new DirectoryValidationManager();
DirectoryValidationResult result = manager.validateDirectory(directoryPath, systemRegistry);
```

## 验证能力

### 1. 文件存在性检查
```xml
<edmx:Reference Uri="external.xml">
    <edmx:Include Namespace="ExternalNamespace"/>
</edmx:Reference>
```
验证：`external.xml`是否在Registry中注册

### 2. 命名空间检查
```xml
<edmx:Include Namespace="ExternalNamespace"/>
```
验证：`ExternalNamespace`是否在Registry中存在

### 3. 类型引用检查
```xml
<EntityType Name="Customer" BaseType="External.Person">
    <Property Name="Address" Type="External.AddressType"/>
    <NavigationProperty Name="Orders" Type="Collection(External.Order)"/>
</EntityType>
```
验证：
- `External.Person`是否在Registry中存在
- `External.AddressType`是否在Registry中存在
- `External.Order`是否在Registry中存在

## 设计优势

### 1. 解耦设计
- 验证逻辑与Schema数据分离
- 可以独立管理和更新Schema信息
- 支持多种数据来源

### 2. 渐进式验证
- 先构建"基础数据"（Registry）
- 基于基础数据验证新文件
- 验证通过的新数据可以合并到基础数据中

### 3. 性能优化
- 一次解析，多次验证
- 避免重复解析相同文件
- 支持增量更新

### 4. 扩展性
- 可以添加更多验证规则
- 支持自定义SchemaRegistry实现
- 支持不同的数据存储方式

## 实际应用场景

### 场景1：初始验证
```java
// 系统初始时，Registry为空
SchemaRegistry emptyRegistry = new SchemaRegistry();

// 验证一组文件，构建基础数据
DirectoryValidationResult result = manager.validateDirectory(baseSchemaDir, emptyRegistry);

// 导出验证通过的基础数据
SchemaRegistry baseRegistry = result.getGeneratedRegistry();
exportRegistry(baseRegistry, "base-schemas.json");
```

### 场景2：增量验证
```java
// 加载之前的基础数据
SchemaRegistry baseRegistry = loadRegistry("base-schemas.json");

// 验证新文件
XmlComplianceResult result = validator.validateWithRegistry(newFile, baseRegistry);

// 如果验证通过，合并新数据
if (result.isCompliant()) {
    SchemaRegistry newData = extractSchemas(newFile);
    baseRegistry.merge(newData);
    exportRegistry(baseRegistry, "updated-schemas.json");
}
```

### 场景3：多层验证
```java
// 系统级Schema（如OData标准类型）
SchemaRegistry systemRegistry = loadSystemSchemas();

// 组织级Schema（如公司标准）
SchemaRegistry orgRegistry = loadOrganizationSchemas();
systemRegistry.merge(orgRegistry);

// 项目级验证
DirectoryValidationResult result = manager.validateDirectory(projectDir, systemRegistry);
```

## 测试覆盖

我们实现了全面的单元测试，覆盖了以下场景：
- ✅ 缺少SchemaRegistry的错误处理
- ✅ HTTP/HTTPS外部引用的正确处理
- ✅ 本地文件引用的存在性检查
- ✅ 命名空间包含检查
- ✅ 类型引用验证（EntityType、ComplexType、Property等）
- ✅ Collection类型的正确处理
- ✅ EDM内置类型的跳过逻辑
- ✅ 当前命名空间类型的跳过逻辑

## 总结

这个实现完全符合您的设计思路：
1. ✅ 提供了"辅助检测接口"（SchemaRegistry）
2. ✅ 实现了跨文件引用的三种验证能力
3. ✅ 支持数据的新增、导出和重用
4. ✅ 实现了解耦设计
5. ✅ 支持渐进式验证流程

通过这个机制，我们可以有效地处理复杂的多文件OData Schema验证场景，提供可靠的跨文件引用检查能力。
