package org.apache.olingo.compliance.file;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.ArrayList;

/**
 * Result of XML file compliance validation with unified issue reporting.
 * Contains detailed information about validation success/failure,
 * structured issues (errors and warnings) with types, and metadata about the validated file.
 */
public class XmlComplianceResult {
    
    private final boolean compliant;
    private final List<ComplianceError> issues; // Unified collection for errors and warnings
    private final Set<String> referencedNamespaces;
    private final Map<String, Object> metadata;
    private final String fileName;
    private final long validationTimeMs;
    
    /**
     * Constructor for XmlComplianceResult
     * 
     * @param compliant whether the file is compliant
     * @param issues all validation issues (errors and warnings)
     * @param referencedNamespaces namespaces referenced in the file
     * @param metadata additional validation metadata
     * @param fileName name of the validated file
     * @param validationTimeMs time taken for validation in milliseconds
     */
    public XmlComplianceResult(boolean compliant, 
                              List<ComplianceError> issues,
                              Set<String> referencedNamespaces, 
                              Map<String, Object> metadata,
                              String fileName, 
                              long validationTimeMs) {
        this.compliant = compliant;
        this.issues = issues != null ? new ArrayList<>(issues) : new ArrayList<>();
        this.referencedNamespaces = referencedNamespaces;
        this.metadata = metadata;
        this.fileName = fileName;
        this.validationTimeMs = validationTimeMs;
    }
    
    /**
     * @return true if the file is compliant with OData 4.0 specification
     */
    public boolean isCompliant() {
        return compliant;
    }
    
    /**
     * Get all validation issues (errors and warnings)
     * 
     * @return list of all ComplianceError objects
     */
    public List<ComplianceError> getIssues() {
        return new ArrayList<>(issues);
    }
    
    /**
     * Get all error issues (severity ERROR)
     * 
     * @return list of error ComplianceError objects
     */
    public List<ComplianceError> getErrors() {
        return issues.stream()
                .filter(issue -> issue.getSeverity() == ComplianceError.Severity.ERROR)
                .collect(Collectors.toList());
    }
    
    /**
     * Get all warning issues (severity WARNING)
     * 
     * @return list of warning ComplianceError objects
     */
    public List<ComplianceError> getWarnings() {
        return issues.stream()
                .filter(issue -> issue.getSeverity() == ComplianceError.Severity.WARNING)
                .collect(Collectors.toList());
    }
    
    /**
     * Get error messages as strings (legacy compatibility)
     * 
     * @return list of error message strings
     * @deprecated Use getErrors() and ComplianceError.getMessage() for structured access
     */
    @Deprecated
    public List<String> getErrorMessages() {
        return getErrors().stream()
                .map(ComplianceError::getMessage)
                .collect(Collectors.toList());
    }
    
    /**
     * Get warning messages as strings (legacy compatibility)
     * 
     * @return list of warning message strings
     * @deprecated Use getWarnings() and ComplianceError.getMessage() for structured access
     */
    @Deprecated
    public List<String> getWarningMessages() {
        return getWarnings().stream()
                .map(ComplianceError::getMessage)
                .collect(Collectors.toList());
    }
    
    /**
     * Check if the result contains issues of a specific type
     * 
     * @param errorType the error type to check for
     * @return true if issues of the specified type exist
     */
    public boolean hasIssueOfType(ComplianceErrorType errorType) {
        return issues.stream().anyMatch(issue -> issue.getErrorType() == errorType);
    }
    
    /**
     * Check if the result contains errors of a specific type
     * 
     * @param errorType the error type to check for
     * @return true if errors (not warnings) of the specified type exist
     */
    public boolean hasErrorOfType(ComplianceErrorType errorType) {
        return getErrors().stream().anyMatch(error -> error.getErrorType() == errorType);
    }
    
    /**
     * Get issues of a specific type
     * 
     * @param errorType the error type to filter by
     * @return list of issues of the specified type
     */
    public List<ComplianceError> getIssuesOfType(ComplianceErrorType errorType) {
        return issues.stream()
                .filter(issue -> issue.getErrorType() == errorType)
                .collect(Collectors.toList());
    }
    
    /**
     * Get errors of a specific type
     * 
     * @param errorType the error type to filter by
     * @return list of errors of the specified type
     */
    public List<ComplianceError> getErrorsOfType(ComplianceErrorType errorType) {
        return getErrors().stream()
                .filter(error -> error.getErrorType() == errorType)
                .collect(Collectors.toList());
    }
    
    /**
     * @return set of namespaces referenced in the validated file
     */
    public Set<String> getReferencedNamespaces() {
        return referencedNamespaces;
    }
    
    /**
     * @return additional metadata about the validation
     */
    public Map<String, Object> getMetadata() {
        return metadata;
    }
    
    /**
     * @return name of the validated file
     */
    public String getFileName() {
        return fileName;
    }
    
    /**
     * @return time taken for validation in milliseconds
     */
    public long getValidationTimeMs() {
        return validationTimeMs;
    }
    
    /**
     * @return true if there are any errors
     */
    public boolean hasErrors() {
        return !getErrors().isEmpty();
    }
    
    /**
     * @return true if there are any warnings
     */
    public boolean hasWarnings() {
        return !getWarnings().isEmpty();
    }
    
    /**
     * @return true if there are any issues (errors or warnings)
     */
    public boolean hasIssues() {
        return !issues.isEmpty();
    }
    
    /**
     * @return number of errors found
     */
    public int getErrorCount() {
        return getErrors().size();
    }
    
    /**
     * @return number of warnings found
     */
    public int getWarningCount() {
        return getWarnings().size();
    }
    
    /**
     * @return total number of issues found
     */
    public int getIssueCount() {
        return issues.size();
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("XmlComplianceResult{");
        sb.append("fileName='").append(fileName).append("'");
        sb.append(", compliant=").append(compliant);
        sb.append(", errors=").append(getErrorCount());
        sb.append(", warnings=").append(getWarningCount());
        sb.append(", validationTime=").append(validationTimeMs).append("ms");
        sb.append("}");
        return sb.toString();
    }
}
